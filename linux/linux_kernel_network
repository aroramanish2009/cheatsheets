Linux Kernel Networking
=======================
OSI Layer:
  - Kernel only handles L2, L3 and L4
  - Session, presentation and application layers are handled solely by userspace applications
  - Layer 1 is also not handled by the linux kernel

Network Device:
  - Network device drivers reside in the layer 2 (datalink layer)
  - net_device is a very large structure, consisting of some device parameters:
    - MTU
    - Mac Addr
    - IRQ number of the device, this is a unique number used to allow CPU to identify a network device.
    - name of the device
    - flags such up/down
    - list of multicast address associated with the device
    - promiscuity counter : Keeps track of entities that requested interface to operate in promiscuous mode
    - features such as GSO offloading etc
    - An object of ethtool callbacks, used to gather info
    - An object of net_device_ops, which consists of functions pointers such as opening/stopping a device,
      changing MTU etc
    - Num if Tx/Rx queues
    - Time Stamps of Rx/Tx of last packet on this device
  - Linux Kernel code for netdevice: https://github.com/torvalds/linux/blob/master/include/linux/netdevice.h
  - Note: When promiscuity counter is larger than 0, network stack does not discards packets that not
    destined to local node.
  - promiscuity counter is used by tcpdump/wireshark, which open raw sockets in userspace and want to receive
    also this type of traffic.
  - "ip -d link show $INTERFACE" will show the value of promiscuity counter, each digit signifies open tcpdump
     sessions.
Network Device New API (NAPI):
  - Before linux kernel 2.4.20, each incoming packet caused an interrupt. In NAPI, under high load, the network
    device works in polling mode and not in interrupt mode.
  - In NAPI, packets are buffered in the driver, and the kernel polls the driver from time to time to fetch
    the packets.
Network Device Receiving and Transmitting packets:
  -  Main tasks of Network Device Driver:
    - To receive packets destined to local host and pass them to higher layers L3 and then to L4
    - To transmit outgoing packets generated on the local host and sent outside, or to forward packets to
      different host that received on local host
  - For each incoming or outgoing packet, a lookup of routing subsystem is performed to make decision on
    next hop interface
  - Packets are also subjected to Netfilter Hooks (details further in notes for Netfilters)
  - Packet traversal can be influenced by IPSec subsystem
  - Other factors such as TTL of IPv4 packet or hop count in ipv6 packet, fragmentation or defragmentation
    of packets, multicast vs unicast etc
  - Socket Buffer (sk_buff) structure represents an incoming or outgoing packet, including its headers
    (include/linux/skbuff.h)
Brief Intro to Socket Buffer:
  - Use SKB API to fetch information from sk_buff
  - When a packet received on the wire:
    - SKB is allocated by the network device driver
    - Typically using netdev_alloc_skb
    - If the packet needs to be discarded, it is done using kfree_skb
  - SKB includes the packet headers (L2, L3, and L4 headers) and the packet payload
  - The network device attached to SKB can influence the traversal of SKB in the Linux Kernel, ex: MTU of
    the network device might require fragmentation etc
  - Each received packet is handled by matching network layer protocol. Ex: ipv4 packet uses ip_rcv() whereas
    ipv6 packet uses ipv6_rcv
  - If the packets are for local delivery, they are delivered to the transport layer
  - Packets generated by the local host are created by Layer 4 sockets—for example, by TCP sockets or by UDP
    sockets. They are created by a userspace application with the Sockets API.
  - Types of Sockets: datagram socket and stream socket
  - Netlink sockets are used to communicate between userspace and kernel

NetLink Sockets:
================
  - RFC 3549, netlink protocol is a socket-based Inter Process Communication (IPC) mechanism.
  - Provides bidirectional communication between userspace and kernel
  - Resides in net/netlink with 4 main files
    - af_netlink.c
    - af_netlink.h
    - genetlink.c
    - diag.c
  - userspace uses socket() sys call to create netlink sockets
  - kernel uses netlink_kernel_create() method to create netlink sockets
Netlink Sockets Libraries:
  - Recommendation is to use libnl API to develop userspace applications, which send or receive data by
    netlink sockets
  - The iproute2 package uses the libnl library
  - sockaddr_nl : Structure represents a netlink socket address. Contains:
    - nl_family #always AF_NETLINK
    - nl_pad # should be 0
    - nl_pid # For kernel socket, it should be 0. For userspace application, if you dont set it or set it
    to 0 the kernel method will try to assign process id of the thread.
    - nl_groups: The multicast group.
Userspace Packages for Controlling TCP/IP Networking:
  - Two packages - net-tools (older) and iproute2
  -  iproute2 components
    - ip: for network table and interfaces
    - tc: for traffic control mgmt
    - ss: for dumping socket statistics
    - lnstat: linux network stats
    - bridge: manage bridge addresses and devices
  - iproute2 is mostly sending requests to kernel from userspace and getting replies from netlink sockets
  - net-tools (old) is based on IOCTL handlers and have commands like ifconfig, arp, route etc
Kernel Netlink Sockets:
  - Several netlink sockets are created in kernel networking stack to handle different types of messages.
  - Ex: Netlink socket that should handle NETLINK_ROUTE is created in rtnetlink_net_init()
  - rtnetlink_net_init() method, after the rtnetlink socket was created by calling netlink_kernel_create(),
  it is assigned to the rtnl pointer of the corresponding network namespace object.
  - netlink_kernel_create(): It's a way for the kernel to set up a special mailbox so that user-space
  programs (like ip, ss etc) can send and receive messages to/from the kernel networking subsystem.
    - This method makes an entry in table named nl_table_lock by calling netlink_insert().
    - Access to this table is controlled by nl_table_lock and lookup is done via netlink_lookup() using
      protocol id and port id.
    - First step to work with netlink kernel socket is to register it using rtnl_register() method.
    - rtnl_register() has 3 functions:
      - rtnl_doit_func : actions like addition/deletion/modification
      - rtnl_dumpit_func : for retrieving information
      - rtnl_calcit_func : calculation of buffer size
    - rtnl_register() adds rtnl_newlink as the doit callback for RTM_NEWLINK messages in the corresponding
      rtnl_msg_handlers entry.
Netlink Messages: These are exchanged between userspace and the kernel. A netlink message always starts
with a netlink message header
  - Netlink Message Header
    - RFC 3549, defined by struct nlmsghdr in include/uapi/linux/netlink.h
    - 16 bytes in size and has 5 fields
    - nlmsg_len: contains length of the message
    - nlmsg_type: There are 4 basic types (addr families can add their own header types as well):
      - NLMSG_NOOP: No operation, message must be discarded
      - NLMSG_ERROR: Error occurred
      - NLMSG_DONE: Multipart message termination signal
      - NLMSG_OVERRUN: error, data was lost
    - nlmsg_flags
      - NLM_F_REQUEST: When it’s a request message
      - NLM_F_MULTI: When it’s a multipart message.
      - NLM_F_ACK: Used to request ACK from receiver of the message
      - Many more flags such as NLM_F_DUMP, NLM_F_ROOT, NLM_F_MATCH, NLM_F_ATOMIC, NLM_F_REPLACE, NLM_F_EXCL etc
    - nlmsg_seq is the sequence number
    - nlmsg_pid is the sending port id. Kernel sent messages are pid 0 and userspace one matches process id
      of the userspace application
  - Netlink Message Payload
    - Uses Type-Length-Value (TLV) format set if attributes
    - Typically 1 to 4 bytes in fixed lengths
    - netlink attribute header is defined by struct nlattr() with nla_len and nla_type
  - NETLINK_ROUTE Messages
    - Used by networking routing subsystem, firewalling, queuing, interface setup etc
    - NETLINK_ROUTE Messages can be divided into families such as LINK, ADDR, ROUTE, NEIGH, TCLASS etc
    - Each of these families have 3 types of messages:
      - RTM_NEWROUTE
      - RTM_DELROUTE
      - RTM_GETROUTE
    - With LINK familiy, you also have RTM_SETLINK for modifying link
    - NETLINK error messages is represented by struct nlmsgerr
  - Adding and Deleting a Routing Entry in RT
    - Ex: When adding route entry using "ip route add x.x.x.x via y.y.y.y"
    - RTM_NEWROUTE Netwlink message is sent from userspace using rtnetlin socket
    - Message is received by rtnetlink socket and handled by rtnetlink_rcv()
    - inet_rtm_newroute() in net/ipv4/fib_frontend.c is invoked to adding the routing entry
    - Insertion into FIB is done via fib_table_insert()
    - rtnl_fib() and rtnl_notify() are used by RTM_NEWROUTE to notify all listeners of RTNLGRP_IPV4_ROUTE
    - Ex: "ip route del x.x.x.x" follows similar processes as above
    - Command sends netlink message RTM_DELROUTE over rtnetlink socket
    - Message is received and handled by rtnetlink_rcv()
    - entry is deleted by inet_rtm_delroute() in net/ipv4/fib_frontend.c
    - Entry is deleted in FIB using fib_table_delete(), which calls rtmsg_fib() for inform listeners
    - "ip monitor route" opens netlink sockets and subscribes to the RTNLGRP_IPV4_ROUTE multicast group. This
       commands then shows messages on stdout when routes are added/deleted via rtnl_notify()
  - Generic Netlink Protocol
    - Netlink has a 32 number of family limitation and NETLINK_GENERIC was created to add higher number
    - Data sent from userspace over generic netlink is handled by genl_rcv() callback
    - It is recommended to use libnl-genl API to open sockets for generic netlink userspace
    - To work with generic netlink sockets in kernel :
      - Create a genl_family object and register it by calling genl_register_family()
      - Create a genl_ops object and register it by calling genl_register_ops()
    - Ex: The wireless subsystem used generic netlink sockets
    - Buffer for a generic netlink message is done like: sk_buff *genlmsg_new(size_t payload, gfp_t flags)
      This is a wrapper arounf nlmsg_new()
    - You can create a generic netlink socket from userspace using "socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC)"
    - Call above is handled in Kernel by netlink_create() much like non generic netlink socket
    - Socket API can be further used for bind(), sendmsg() or recvmsg()
  - Socket Monitoring Interface
    - Used by userspace tools like ss
    - Netlink-based subsystem use sock_diag to get information about sockets
    - This API is also used by Checkpoint/Restore functionality for Linux userspace (CRIU)
    - checkpointing a process = saving the state of a process to the filesystem

ICMP
====
  - default location: net/ipv4/icmp.c
  - inet_init()
    - invoked during boot process
    - calls icmp_sk_init() for kernel to reply to ICMP messages

static const struct net_protocol icmp_protocol = {
.handler = icmp_rcv,  ## Invoked for IPPROTO_ICMP (0x1) in the IP protocol field
.err_handler = icmp_err,  ##
.no_policy = 1, ## No need to check IPSEC Policy
.netns_ok = 1, ## required for kernel 3 and up to understand network namespaces
};
(net/ipv4/af_inet.c)
  - ICMPv4 Header
    - 8 bits for type
    - 8 bits for code
    - 16 bits for checksum
    - 32 bits for variable, used by type/code
    - plus payload
  - All host must be capable of accepting  576 octets of data.
  - location: include/uapi/linux/icmp.h
  - ICMP_TIMESTAMP and the ICMP_TIMESTAMPREPLY # sometimes used for time sync, recv host replies to timestamp message with icmp packet that contains Originator timestamps, recv timestamp and transmit timestamp.
  - icmp_unreach() handles ICMP_DEST_UNREACH, ICMP_TIME_EXCEED, ICMP_PARAMETERPROB, and ICMP_QUENCH message types
  - ICMP_DEST_UNREACH # details later
  - ICMP_TIME_EXCEED #
    - code ICMP_EXC_TTL is sent, the SKB is freed, the InHdrErrors SNMP counter (IPSTATS_MIB_INHDRERRORS) is incremented, and the method returns NET_RX_DROP.
    - also sent when timeout of a fragment occurs, see net/ipv4/ip_fragment.c
  - ICMP_PARAMETERPROB # Sent when parsing the options of an IPv4 header fails
  - ICMP_QUENCH # deprecated, was intended to be used to report congestion but it didn't work

Receiving ICMPv4 Messages:
==========================
  - On receive of the icmp packet, ip_local_deliver_finish() delivers it to raw socket that opened ICMP protocol
  - icmp_rcv() method functions
    - InMgs SNMP counter (ICMP_MIB_INMSGS) is incremented
    - checksum is checked, if incorrect InCsumErrors and InErrors (ICMP_MIB_CSUMERRORS and ICMP_MIB_INERRORS, respectively), the SKB is freed, and the method returns 0
    - ICMP header is examined and checked for correct values
    - In unknown type icmp packets are received, InMgs SNMP counter (ICMP_MIB_INMSGS) is incremented and packet is silently discarded
    - /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts is set to 1 by default, which means that icmp broadcast and multicast packets should be discarded as per the RFC guidelines
    - icmp_echo() method is called if packet received is an type ECHO packet, icmp_echo() changes the header type to REPLY and called icmp_reply() method
    - icmp echo and icmp timestamp are only to packets that requires a return packet
    - Sending is done by ip_append_data() and by ip_push_pending_frames()
  - How to disable all ICMP replies: echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all
  - icmp_discard() is used is ICMP type is supported by Linux Kernel

ICMPv4 Destination Unreachable:
===============================
  - icmp_reply() is normally used for ECHO, TIMESTAMP messages
  - icmp_send() can be invoked from many places in the IPv4 network stack—for example, from netfilter, from the forwarding code (ip_forward.c), from tunnels like ipip and ip_gre, and more.
  - Code 2 ICMP_DEST_UNREACH/ICMP_PROT_UNREACH is sent when the protocol in ipv4 packet does not exist or supported in the linux kernel.
  - Code 3 ICMP_PORT_UNREACH is sent when UDPv4 packet is received, checksum is correct but no matching socket is found. net/ipv4/udp.c -> __udp4_lib_lookup_skb()
  - Code 4 ICMP_FRAG_NEEDED, if the don’t fragment (DF) bit in the IPv4 header (IP_DF) is set, the packet is discarded and an ICMP_DEST_UNREACH message with ICMP_FRAG_NEEDED code is sent back to the sender
  - Code 5 ICMP_SR_FAILED, sent if IP packet have strict routing option enabled and gateway is set
  - NOTE: iptables REJECT target and the --reject-with qualifier can be used for sending ICMP_DEST_UNREACH messages

ICMPv6:
=======
  - Next protocol header value of 58, for incoming packets with protocol field 58, icmpv6_rcv() will be revoked
  - ICMPv6 is a must for ipv6 node
  - Used for Neighbor discovery (ipv4 used arp) and Multicast Listener Discovery (IPv4 used IGMP)
  - Implemented in net/ipv6/icmp.c and in net/ipv6/ip6_icmp.c
  - kernel initialization is done by icmpv6_init() method + icmpv4_sk_init()
  - ICMPv6 Header:
    - 8 bits for type, 8 bits for code and 16 bits for checksum + payload
    - Represented in struct icmp6hdr
    - If high-order bit of the type field == 0 (value range 0 to 127) then it represents error message
    - If high-order bit of the type field == 1 (value range 128 to 255) then it represents info message
    - see: https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xml Type to Message mapping
  - Receiving ICMPv6 Messages:
    - Incoming icmpv6 packet is delivered to icmpv6_rcv() with SKB as parameter
    - icmpv6_rcv()
      - checks checksum, if fails, increments InErrors SNMP counter and discards packet
      - if checksum passes, icmp header is read for type and corresponding procfs counter in incremented
      - Handlers are invoked as per icmpv6 type
      - echo request -> icmpv6_echo_reply()
      - Echo Reply” (ICMPV6_ECHO_REPLY) is handled by the ping_rcv() method. (dual stack method)
      - Packet too big (ICMPV6_PKT_TOOBIG) -> pskb_may_pull() check data whose size should be at least as big as ICMP header or packet is dropped.
        icmpv6_notify() -> raw6_icmp_error() are invoked to handle ICMP messages.
      - ICMPV6_DEST_UNREACH, ICMPV6_TIME_EXCEED, and ICMPV6_PARAMPROB -> icmpv6_notify()
      - Neighbour Discovery (ND) messages
        - NDISC_ROUTER_SOLICITATION: all-routers multicast address of FF02::2,
          and which are answered by router advertisements
        - NDISC_ROUTER_ADVERTISEMENT: Sent periodically by routers or in response to above message. Contains info
          above prefixes for on-link determination and/or address config info
        - NDISC_NEIGHBOUR_SOLICITATION and NDISC_NEIGHBOUR_ADVERTISEMENT : ARP counterpart
        - NDISC_REDIRECT: Same as ICMPv4 redirect
        - All ND messages are handled by ndisc_rcv() (net/ipv6/ndisc.c)
      - ICMPV6_MGM_QUERY (Multicast Listener Report): igmpv6_event_query()
      - ICMPV6_MGM_REPORT (Multicast Listener Report): igmp6_event_report()
      - Messages of unknown type, and the following messages are handled by impv6_notify()
        - ICMPV6_MGM_REDUCTION: When host leaves Multicast group
        - ICMPV6_MLD2_REPORT: MLDv2 Multicast Listener Report packet
        - ICMPV6_NI_QUERY- ICMP: Node Information Query
        - ICMPV6_NI_REPLY: ICMP Node Information Response
        - ICMPV6_DHAAD_REQUEST: For mobility support in IPv6. RFC 6257
        - ICMPV6_DHAAD_REPLY: same as above, RFC 6257
        - ICMPV6_MOBILE_PREFIX_SOL: ICMP Mobile Prefix Solicitation Message Format;RFC 6257
        - ICMPV6_MOBILE_PREFIX_ADV: ICMP Mobile Prefix Advertisement Message Format;RFC 6257
    - Sending ICMPv6 Messages: Local machine invokes icmpv6_send() under many conditions. There is also
      icmpv6_echo_reply() which is invoked in response to ICMPV6_ECHO_REQUEST. Examples:
      - Hop Limit Counter: IPv6 hop counter is 0 (same as TTL), ICMPV6_TIME_EXCEED message is sent
        with ICMPV6_EXC_HOPLIMIT code by icmpv6_send().
      - Fragment Reassembly Time Exceeded: icmpv6_send() -> ICMPV6_TIME_EXCEED (ICMPV6_EXC_FRAGTIME code)
      - Destination Unreachable/Port Unreachable: UDPv6 incoming packets require matching UDPv6 socket, if
        no matching socket is found and checksum is valid, UDP_MIB_NOPORTS MIB counter is incremented and
        icmpv6_send() is used to send "Destination Unreachable/Port Unreachable" message. Incorrect checksum
        leads to silent drop.
      - Fragmentation Needed: When forwarding packet, if packet size is larger than MTU on the outgoing interface
        and local_df bit in the SKB is not set, packet is discarded and ICMPV6_PKT_TOOBIG is sent. NOTE: In IPv4,
        ICMP_DEST_UNREACH is sent with code ICMP_FRAG_NEEDED where as in IPv6 ICMPV6_PKT_TOOBIG has its on Type.
      - Parameter Problem: Any problems in parsing ext headers, an ICMPV6_PARAMPROB message with ICMPV6_UNK_OPTION
        code is sent back.
Kernel level sysctl variables:
  - sysctl_icmp_echo_ignore_all: When set, will ignore icmp_echo packets
  - sysctl_icmp_echo_ignore_broadcasts: When set, will ignore echo/timestamp packets destined to broadcast/multicast
    address
  - sysctl_icmp_ignore_bogus_error_responses: When set, will not log errors messages
  - sysctl_icmp_ratelimit: Limit the maximal rates for sending ICMP packets whose type matches the icmp ratemask
  - sysctl_icmp_ratemask: ICMP types for which rates are being limited
  - sysctl_icmp_errors_use_inbound_ifaddr: When set, ICMP message will be sent with the primary address of the
    interface that received the packet that caused the icmp error

IPv4
====
  - IP Header: atleast 20 bytes long, with IP options it can be upto 60 bytes
  - IP Header: Represented by iphdr struct. See description of IPv4 header:
    - ihl: Length of IP Header measured in multiple of 4 bytes. ihl value can be minimum 5 (4 x 5 bytes = 20)
      to max 15 (4 x 15 bytes = 60). IPv4 header must be aligned to 4-byte boundary
    - version: Should be 4
    - tos: "Type of service", Intended got QoS. RFC 2474, defines DSCP to use 0 to 5 bits of tos and bit 6/7
      is used fo ECN based on RFC 3168
    - tot_len: total length, including the header, measured in bytes. Minimum size is 576 bytes
    - id: Used in fragmentation/reassembling. id value of all the fragments of that SKB should be the same.
    - frag_off: fragment offset, 16 bit field. The lower 13 bits are the offset of the fragment. In the first
      fragment, the offset is 0. The offset is measured in units of 8 bytes. The higher 3 bits are the flags:
      - 001 = MF (more Fragments). It is set for all fragments, except the last one.
      - 010 = DF (don’t Fragment)
      - 100 = CE (congestion)
    - ttl: aka hop counter, packet is discard if ttl = 0 and ICMPv4 time exceeded is sent.
    - protocol: L4 protocol of IP packet. Ex: IPPROTO_TCP for TCP traffic or IPPROTO_UDP for UDP traffic
    - check: 16 bit checksum field
    - saddr: source address, 32 bit
    - daddr: destination address, 32 bit.
IPv4 Initialization:
  - IPv4 packets are ethernet type 0x0800, it is stored in first 2 bytes of 14 byte ethernet header
  - inet_init() method is called during boot phase to perform IPv4 initialization
  - dev_add_pack() method adds the ip_rcv() method as a protocol handler for IPv4
Receiving IPv4 Packets:
  - ip_rcv() -- performs sanity checks --> invokes ip_rcv_finish()
  - Between ip_rcv() and ip_rcv_finish(), NF_INET_PRE_ROUTING netfilter hook is invoked by calling
    NF_HOOK macro
  - Netfilter hooks:
    - NF_INET_PRE_ROUTING
    - NF_INET_LOCAL_IN
    - NF_INET_FORWARD
    - NF_INET_POST_ROUTING
    - NF_INET_LOCAL_OUT (used when sending ipv4 packet out)
  - Sanity Check performed by ip_rcv()
    - ihl (ipv4 header length) measured in multiple of 4 and must be 5 (4bytes x 5 = 20 bytes) atleast
    - version should be 4
    - if above 2 does not pass, packet is dropped and IPSTATS_MIB_INHDRERRORS is updated
    - ip header checksum is verified and packet is dropped silently if bad checksum. This checksum is calculated
      only over ipv4 header bytes.
  - If Sanity check passes, NF_HOOK macro is invoked
    - return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,ip_rcv_finish);
    - if registered netfilter hook method returns NF_DROP, packet is dropped right away and traversal is stopped
    - if hook returns NF_STOLEN, packet is taken over by NetFilter subsystem and traversal stopped
    - NF_ACCEPT return, packet continues its traversal
    - More NF_HOOK verdicts are describe in other chapter
  - ip_rcv_finish() method
    - uses skb_dst() to check for dst object (instance of dst_entry) attached to SKB
    - dst_entry lookup is doing according to routing table and packet headers
    - Lookup in the routing subsystem sets input/output callbacks of the dst
      - If packet is destined for local machine, input callback set to ip_local_deliver()
      - If packet needs to be forwarded, input callback set to ip_forward()
      - If multicast packet (in some cases), it can be ip_mr_input()
    - Note: If not dst in SKB, lookup is done by ip_route_input_noref(), if lookup fails, the packet is discarded
    - If Reverse path filter is enabled and "-EXDEV" is returned by __fib_validate_source(), packet is dropped
      and LINUX_MIB_IPRPFILTER is incremented. See counters in /proc/net/netstat - IPReversePathFilter column
======
Note: Script to check /proc/net/netstat file in human readable format
#!/bin/bash

file="/proc/net/netstat"

# Read the file line by line in pairs (header + values)
while read -r header && read -r values; do
    # Drop the first column (like "TcpExt:" or "IpExt:")
    header_fields=($(echo $header | cut -d' ' -f2-))
    value_fields=($(echo $values | cut -d' ' -f2-))

    # Print them in name = value format
    for i in "${!header_fields[@]}"; do
        echo "${header_fields[$i]} = ${value_fields[$i]}"
    done
    echo "------------------------------------"
done < "$file"
./netstat_parser.sh | grep IpReversePathFilter
======
    - next ip options are checked
      - if ipv4 header length is more than 5 (4x 5bytes = 20 bytes) means it containes IP Options
      - if above is true, ip_rcv_options() is invoked to handle options
    - If it is Multicast -> IPSTATS_MIB_INMCAST statistics is updated and dst_input() is invoked
    - If it is Broadcast -> IPSTATS_MIB_INBCAST is updated and dst_input() is invoked

Receiving IPv4 Multicast Packets
  - ip_rcv() is also the handler of multicast packets
  - After same process of sanity checks, NFHOOKs, ip_rcv_finish() invokes routing subsystem
  - ip_route_input_noref() of routing subsystem:
    - check if the local machine belongs to multicast group of the dest multicast address by calling
      ip_check_mc_rcu(). If machine belongs to multicast group or is Multicast router, ip_route_input_mc is invoked.
    - if machine is part of dst multicast group then input callback of dst is set to ip_local_deliver
    - if machine is multicast router and IN_DEV_MFORWARD(in_dev) is set, then input callback of dst is
      set to ip_mr_input()
  - Basically ip_rcv_finish() -> dst_input(skb) -> ip_local_deliver() or ip_mr_input()
  - IN_DEV_MFORWARD(in_dev) macro checks procfs multicast forward entry
  - /proc/sys/net/ipv4/conf/all/mc_forwarding is readonly and enabled automatically when PIM daemon is started
  - ip_mr_forward() is called if a valid entry is found in Multicast Forwarding Cache (MFC: data structure used
    by multicast layer)
  - ip_mr_forward() method performs some checks and eventually calls the ipmr_queue_xmit() method
  - ipmr_queue_xmit() -- decreased ttl -- NFHOOKS -- ipmr_forward_finish()
  - ipmr_forward_finish() -- updated statistics -- call ip_forward_option() if needed -- calls dst_output()

IP Options:
  - IP header may contain zero, 1 or more options.
  - Two forms of ip options:
    - single byte option: “End of Option List” and “No Operation” are the only single byte option.
    - Multibyte Option: Length of the option (1byte) + Pointer offset from option start (1 byte) + Option Data
Different IP Options:
  - End of Option List (IPOPT_END): 1 byte option indicating end of options field.
  - No Operation (IPOPT_NOOP): 1 byte option used for internal padding.
  - Security (IPOPT_SEC): Option for hosts to send security, handling restrictions and TCC parameters.
  - Loose Source Record Route (IPOPT_LSRR): Specifies list of router that the packet should traverse.
  - Commercial Internet Protocol Security Option (IPOPT_CIPSO): IETF draft, it gives a way of attaching security
    labels to IP Packets. Outgoing packets get labeled, and incoming packets are checked against those labels to
    enforce security policies.
  - Timestamp Option:
    - IPOPT_TIMESTAMP: Stores timestamp of hosts along the packet route.
    - Stored timestamp is a 32 bit timestamp in ms since midnight UTC of current day
    - Can store timestamp of all hosts in path or certain selected hosts along the route
    - Max option length is 40 bytes
    - Not copied to all fragments and only carried in first fragment
    - ping -T tsonly/tsandaddr/tsprespec x.x.x.x can be used to see timestamps/hops.
    - ping -T tsprespec <destination> <prespecified IPs...> -> Timestamps only specified hops.
    - ping command above does need devices with NTP/PTP from same time source
    - When there is no more space add timestamps data, the overflow counter is incremented.
  - Record Route Option:
    - IPOPT_RR: route of a packet is recorded
    - IP Header only has enough space to store upto 9 hops due 40 byte limitation
    - Most routers/switch will drop packets with option
  - Stream ID (IPOPT_SID): Used on network that does not support Stream concept
  - Strict Source Record Route (IPOPT_SSRR): Many routers/switches block this option, it specifies a
    list of routers that the packet should traverse.
  - Router Alert (IPOPT_RA): Alerts IP router in transit for examine the contents of IP packet.
  - IP_OPTIONS Struct is located in include/net/inet_sock.h
  - ip_options_compile() can be invoked from ip_rcv_options() or ip_options_get_finish() method
  - “Parameter Problem” ICMPv4 message (ICMP_PARAMETERPROB) is sent back if a parsing error is detected in
    RX path. (RX Path = ip_options_compile() invoked from ip_rcv_options())
  - No Operation (IPOPT_NOOP) and End of Option List (IPOPT_END) are the only single byte options
  - For Strict Source Record Route, /proc/sys/net/ipv4/conf/all/accept_source_route should be set otherwise
    packet is dropped.
IP Options and Fragmentation:
  - ip_options_fragment() method is used to handle ip options in fragments
  - ip_options_fragment() is invoked by ip_fragment() method
Building IP Options:
  - ip_options_build() method is used to write content to IPv4 Header
  - ip_options_build() takes ip_options object as an argument and writes it to header

Sending IPv4 Packets:
  - 2 methods used to send IPv4 packets ip_queue_xmit() and ip_append_data() method
  - TCP uses ip_queue_xmit() method as it manages it's own fragmentation. NOTE: TCPv4 also uses
    ip_build_and_send_pkt() method to send certain packets like SYN_ACK packets
  - UDPv4/ICMPv4 uses ip_append_data() method as they do not handle fragmentation
  - NOTE: ip_append_data() method only prepares the packet, ip_push_pending_frame() is used for sending the
    packet. It does that by invoking ip_send_skb() which then calls ip_local_out()
  - In newer kernels, UDPv4 uses ip_send_skb() method instead of ip_push_pending_frame()
  - There are cases where dst_output() is used directly, for ex: Sending raw sockets which uses IP_HDRINCL
    socket option. Userspace apps that build their own IPv4 use this socket option. Ex: ping/nping etc as they
    allow users to set ttl in ipv4 headers
  - ip_queue_xmit() Method
    - Can we route this packet
    - route table is checked to see if we can route to the dest address.
    - If the rtable instance is NULL, method checks if IP Option Strict routing flag is set, if set, dest
      add is set to first addr of IP Option.
    - If IP Option Strict routing flag is not set, ip_route_output_ports() method performs route lookup, if
      fails, packet is dropped and -EHOSTUNREACH is returned. Layer 4 retrans method will keep trying here.
    - next check, if IP Option Strict route flag and RT_USES_GATEWAYS flag are both set, packet is dropped
    - skb->data is pointed to transport header. skb_push() is used to offset/push back skb->data to make
      room for ipv4 headers + options (if any)
    - ip_options_build() is used if any options are needed based on content of IP Options
    - ID is set in IPv4 Header, this ID is more useful in fragmentation as all frag's of the packet
      will have same ID.
  - ip_append_data() method
    - getfrag() callback is used to copy actual data from userspace into SKB
    - For UDPv4 getfrag() callback is set to be the generic method, ip_generic_getfrag()
    - For ICMPv4, getfrag() callback is set to be a protocol-specific method, icmp_glue_bits()
    - MSG_PROBE flag - If set, it means caller is interested only in info like MTU for Path MTU Discovery.
      There is no need to send actual packet and method returns 0
Fragmentation:
  - 94
